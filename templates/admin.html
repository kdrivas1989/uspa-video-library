<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>http://videos.kd-evolution.com/videoupload</title>
    <link href="/static/css/tailwind.css" rel="stylesheet">
    {% if dropbox_app_key %}
    <script src="https://www.dropbox.com/static/api/2/dropins.js" id="dropboxjs" data-app-key="{{ dropbox_app_key }}"></script>
    {% endif %}
</head>
<body class="bg-gray-900 text-white min-h-screen">
    <nav class="bg-purple-800 p-4 sticky top-0 z-10">
        <div class="container mx-auto flex justify-between items-center">
            <a href="/videoupload" class="text-2xl font-bold text-white">Video Upload</a>
            <div class="flex items-center gap-4">
                <a href="/" target="_blank" class="bg-green-600 hover:bg-green-500 px-4 py-2 rounded-lg font-semibold">Videos</a>
                <a href="/competitions" target="_blank" class="bg-yellow-600 hover:bg-yellow-500 text-black px-4 py-2 rounded-lg font-semibold">Competitions</a>
                <a href="/draw-generator" target="_blank" class="bg-purple-600 hover:bg-purple-500 px-4 py-2 rounded-lg font-semibold">Draw Generator</a>
                <a href="/assignments" target="_blank" class="bg-cyan-600 hover:bg-cyan-500 px-4 py-2 rounded-lg font-semibold">Assign Videos</a>
                {% if is_admin %}
                <a href="/admin/users" target="_blank" class="bg-blue-600 hover:bg-blue-500 px-4 py-2 rounded-lg">Users</a>
                {% endif %}
                <a href="/logout" class="text-purple-200 hover:text-white">Logout</a>
            </div>
        </div>
    </nav>

    <div class="container mx-auto px-4 py-8">
        <!-- Stats -->
        <div class="grid md:grid-cols-3 gap-6 mb-8">
            <div class="bg-gray-800 rounded-lg p-6">
                <p class="text-4xl font-bold text-blue-400">{{ total_videos }}</p>
                <p class="text-gray-400 mb-3">Total Videos</p>
                <div class="text-xs space-y-1">
                    {% for cat_id, cat in categories.items() %}
                    {% if category_counts.get(cat_id, 0) > 0 %}
                    <div class="flex justify-between">
                        <span class="text-gray-500">{{ cat.abbrev }}</span>
                        <span class="text-gray-400">{{ category_counts.get(cat_id, 0) }}</span>
                    </div>
                    {% endif %}
                    {% endfor %}
                </div>
            </div>
            <div class="bg-gray-800 rounded-lg p-6">
                <p class="text-gray-400 text-sm mb-2">Auto-categorize from filenames</p>
                <div class="flex items-center gap-2 mb-2">
                    <select id="autoCategorizeScope" class="bg-gray-700 text-white text-sm px-2 py-1 rounded">
                        <option value="uncategorized">Uncategorized Only</option>
                        <option value="all">All Files (PIN required)</option>
                    </select>
                </div>
                <button onclick="autoCategorize()" id="autoCategorizeBtn" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded-lg text-sm">
                    Auto-Categorize
                </button>
                <p id="autoCategorizeMessage" class="text-sm mt-2 hidden"></p>
            </div>
            <div class="bg-gray-800 rounded-lg p-6">
                <p class="text-gray-400 text-sm mb-3">Remove duplicate videos (same URL or title+duration)</p>
                <button onclick="fixDuplicates()" class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded-lg text-sm">
                    Fix Duplicates
                </button>
                <p id="fixDuplicatesMessage" class="text-sm mt-2 hidden"></p>
            </div>
            <div class="bg-gray-800 rounded-lg p-6">
                <p class="text-gray-400 text-sm mb-3">Generate thumbnails for S3 videos (10 at a time)</p>
                <button onclick="refreshThumbnails(true)" id="refreshThumbsBtn" class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded-lg text-sm">
                    Generate Thumbnails
                </button>
                <button onclick="stopThumbnailGeneration()" id="stopThumbsBtn" class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded-lg text-sm hidden ml-2">
                    Stop
                </button>
                <p id="refreshThumbsMessage" class="text-sm mt-2 hidden"></p>
                <p id="refreshThumbsProgress" class="text-xs text-gray-500 mt-1 hidden"></p>
            </div>
            <div class="bg-gray-800 rounded-lg p-6">
                <p class="text-gray-400 text-sm mb-3">Scan videos and detect durations using ffprobe</p>
                <button onclick="scanDurations()" id="scanDurationsBtn" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded-lg text-sm">
                    Scan Durations
                </button>
                <p id="scanDurationsMessage" class="text-sm mt-2 hidden"></p>
            </div>
        </div>

        <!-- Background Conversion Status -->
        <div id="conversionStatusPanel" class="bg-gray-800 rounded-lg p-6 mb-8 hidden">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold">Background Conversions</h2>
                <button onclick="clearCompletedConversions()" class="text-sm text-gray-400 hover:text-white">
                    Clear Completed
                </button>
            </div>
            <div id="conversionJobsList" class="space-y-3">
                <!-- Jobs will be inserted here -->
            </div>
        </div>

        <!-- S3 Upload Status Banner -->
        <div id="s3StatusBanner" class="hidden bg-yellow-900/30 border border-yellow-700 rounded-lg p-4 mb-8">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <svg class="w-6 h-6 text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                    </svg>
                    <div>
                        <span class="text-yellow-400 font-medium">AWS S3 Not Connected</span>
                    </div>
                </div>
                <span class="text-gray-400 text-sm">Videos will be stored locally</span>
            </div>
        </div>

        <!-- Direct File Upload -->
        <div class="bg-gray-800 rounded-lg p-6 mb-8">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-xl font-bold">Upload Video Files</h2>
                <div class="flex items-center gap-4">
                    <button onclick="showConverterModal()" class="px-3 py-1 bg-orange-600 hover:bg-orange-700 rounded text-sm font-medium flex items-center gap-2">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                        </svg>
                        Local Converter
                    </button>
                    <div id="uploadDestination" class="text-sm">
                        <span class="text-gray-400">Upload to: </span>
                        <span id="uploadDestinationLabel" class="text-blue-400">Local/Supabase</span>
                    </div>
                </div>
            </div>
            <p class="text-gray-400 text-sm mb-4">
                Drop files or folders. For nested folders: <span class="text-cyan-400">MainFolder</span> = Event, <span class="text-green-400">Subfolder</span> = Category
            </p>

            <div id="manualCategorySection" class="flex flex-wrap gap-4 items-end mb-4">
                <div class="w-48">
                    <label class="block text-gray-300 mb-2">Category</label>
                    <select id="uploadCategory"
                        class="w-full px-4 py-2 rounded-lg bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-purple-500"
                        onchange="updateUploadSubcategories()">
                        <option value="">Auto-detect from filename</option>
                        {% for cat_id, cat in categories.items() %}
                        <option value="{{ cat_id }}">{{ cat.abbrev }} - {{ cat.name }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div id="uploadSubcategoryDiv" class="w-48 hidden">
                    <label class="block text-gray-300 mb-2">Subcategory</label>
                    <select id="uploadSubcategory"
                        class="w-full px-4 py-2 rounded-lg bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-purple-500">
                        <option value="">Select</option>
                    </select>
                </div>
                <div class="w-64">
                    <label class="block text-gray-300 mb-2">Event</label>
                    <input type="text" id="uploadEvent" list="uploadEventList"
                        class="w-full px-4 py-2 rounded-lg bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-purple-500"
                        placeholder="e.g., 2024 Nationals">
                    <datalist id="uploadEventList">
                        {% for event in events %}
                        <option value="{{ event }}">
                        {% endfor %}
                    </datalist>
                </div>
                <div class="w-64">
                    <label class="block text-gray-300 mb-2">Video Labeling Format</label>
                    <select id="uploadLabelFormat"
                        class="w-full px-4 py-2 rounded-lg bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-purple-500">
                        <option value="auto">Auto-detect</option>
                        <option value="team_space_round">Team Round (e.g., 226 5)</option>
                        <option value="team_underscore_round">Team_Round (e.g., 226_5)</option>
                        <option value="team_dash_round">Team-Round (e.g., 226-5)</option>
                        <option value="uspa_competition">USPA Competition (Comp_Event_Team-Name_Round)</option>
                        <option value="round_only">Round only (e.g., Round 5)</option>
                        <option value="custom">Custom (ask me)</option>
                    </select>
                </div>
            </div>
            <div id="dropZone"
                class="border-2 border-dashed border-gray-600 rounded-lg p-8 text-center cursor-pointer hover:border-purple-500 transition"
                ondrop="handleDrop(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)"
                onclick="document.getElementById('fileInput').click()">
                <input type="file" id="fileInput" multiple accept="video/*,.mts,.m2ts,.avi,.mkv" class="hidden" onchange="handleFileSelect(event)">
                <svg class="w-12 h-12 mx-auto text-gray-500 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                </svg>
                <p class="text-gray-400">Drag & drop files or folders here</p>
                <p class="text-green-500 text-sm mt-2">Supported: MP4, WebM, MOV, MKV, AVI, MTS</p>
                <p class="text-cyan-500 text-xs mt-1">MKV, AVI, MTS files will be converted to MP4 automatically on the server</p>
                <p class="text-gray-600 text-xs mt-1">Folder structure: EventName/Category/videos.mp4</p>
            </div>
            <div id="uploadProgress" class="mt-4 hidden"></div>
            <div id="uploadResults" class="mt-4 hidden"></div>
            <!-- Inline Conversion Status (shown during/after uploads) -->
            <div id="inlineConversionStatus" class="mt-4 hidden">
                <div class="bg-yellow-900/30 border border-yellow-600 rounded-lg p-4">
                    <div class="flex items-center justify-between mb-3">
                        <h3 class="text-yellow-400 font-semibold flex items-center gap-2">
                            <span class="animate-pulse">‚öôÔ∏è</span> Converting Videos
                        </h3>
                        <span id="inlineConversionCount" class="text-gray-400 text-sm"></span>
                    </div>
                    <div id="inlineConversionList" class="space-y-2">
                        <!-- Jobs will be inserted here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Video List -->
        <div class="bg-gray-800 rounded-lg p-6">
            <h2 class="text-xl font-bold mb-4">Manage Videos</h2>
            <!-- Filter by Event -->
            <div class="flex flex-wrap gap-4 mb-4">
                <div>
                    <label class="block text-gray-400 text-sm mb-1">Filter by Event</label>
                    <select id="filterEventSelect" onchange="filterVideosByEvent()" class="px-4 py-2 rounded bg-gray-700 text-white">
                        <option value="">All Events</option>
                        <option value="__none__">No Event Assigned</option>
                        {% for event in events %}
                        <option value="{{ event }}">{{ event }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div>
                    <label class="block text-gray-400 text-sm mb-1">Bulk Assign Event</label>
                    <div class="flex gap-2">
                        <input type="text" id="bulkEventInput" list="bulkEventList" placeholder="Event name..." class="px-3 py-2 rounded bg-gray-700 text-white w-48">
                        <datalist id="bulkEventList">
                            {% for event in events %}
                            <option value="{{ event }}">
                            {% endfor %}
                        </datalist>
                        <button onclick="bulkAssignEvent()" class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded text-sm">Assign to Visible</button>
                    </div>
                </div>
                <div class="flex items-end gap-2">
                    <button onclick="sortByTeamRound()" class="bg-purple-600 hover:bg-purple-700 px-4 py-2 rounded text-sm">Sort by Team/Round</button>
                    <span id="videoFilterCount" class="text-gray-500 text-sm"></span>
                </div>
            </div>
            <div class="space-y-3 max-h-[800px] overflow-y-auto" id="videoListContainer">
                {% if videos %}
                {% for video in videos %}
                <div class="bg-gray-700 rounded-lg p-4 video-list-item" data-video-id="{{ video.id }}" data-event="{{ video.event|default('', true) }}">
                    <div class="flex gap-4">
                        <div class="w-32 h-20 bg-gray-600 rounded flex-shrink-0 overflow-hidden">
                            {% if video.thumbnail %}
                            <img src="{{ video.thumbnail }}" alt="{{ video.title }}" class="w-full h-full object-cover">
                            {% endif %}
                        </div>
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center gap-2">
                                <input type="text" value="{{ video.title }}"
                                    class="flex-1 font-semibold text-white bg-transparent border-b border-transparent hover:border-gray-500 focus:border-blue-500 focus:outline-none px-1 py-0.5"
                                    onchange="quickRenameVideo('{{ video.id }}', this.value)"
                                    onkeydown="if(event.key==='Enter'){this.blur();}">
                            </div>
                            <div class="flex items-center gap-2 mt-1 text-sm text-gray-400">
                                <select onchange="quickChangeCategory('{{ video.id }}', this.value, this)"
                                    class="bg-blue-600 text-white px-2 py-0.5 rounded text-xs cursor-pointer hover:bg-blue-500"
                                    data-video-id="{{ video.id }}">
                                    {% for cat_id, cat in categories.items() %}
                                    <option value="{{ cat_id }}" {% if cat_id == video.category %}selected{% endif %}>{{ cat.abbrev }}</option>
                                    {% endfor %}
                                </select>
                                <select onchange="quickChangeSubcategory('{{ video.id }}', this.value)"
                                    class="bg-gray-600 text-white px-2 py-0.5 rounded text-xs cursor-pointer hover:bg-gray-500 subcategory-select"
                                    data-video-id="{{ video.id }}" data-current="{{ video.subcategory|default('', true) }}"
                                    {% if not categories.get(video.category, {}).get('subcategories') %}style="display:none"{% endif %}>
                                    <option value="">--</option>
                                    {% if categories.get(video.category, {}).get('subcategories') %}
                                    {% for sub in categories.get(video.category, {}).get('subcategories', []) %}
                                    <option value="{{ sub.id }}" {% if sub.id == video.subcategory %}selected{% endif %}>{{ sub.name }}</option>
                                    {% endfor %}
                                    {% endif %}
                                </select>
                                <span>{{ video.views }} views</span>
                                <span class="text-gray-500">|</span>
                                <input type="text" value="{{ video.event|default('', true) }}"
                                    list="eventList_{{ video.id }}"
                                    placeholder="No event"
                                    class="bg-cyan-700 text-white px-2 py-0.5 rounded text-xs w-32 event-input"
                                    data-video-id="{{ video.id }}"
                                    onchange="quickChangeEvent('{{ video.id }}', this.value)">
                                <datalist id="eventList_{{ video.id }}">
                                    {% for event in events %}
                                    <option value="{{ event }}">
                                    {% endfor %}
                                </datalist>
                            </div>
                            <div class="flex gap-2 mt-3">
                                <button onclick="editVideo('{{ video.id }}')"
                                    class="text-blue-400 hover:text-blue-300 text-sm">Details</button>
                                <button onclick="deleteVideo('{{ video.id }}')"
                                    class="text-red-400 hover:text-red-300 text-sm">Delete</button>
                                <a href="/video/{{ video.id }}" target="_blank"
                                    class="text-gray-400 hover:text-gray-300 text-sm">View</a>
                            </div>
                        </div>
                    </div>
                </div>
                {% endfor %}
                {% else %}
                <div class="text-center py-8 text-gray-500">
                    <p>No videos yet. Upload videos using the sections above.</p>
                </div>
                {% endif %}
            </div>
        </div>
    </div>

    <!-- Bulk Upload Modal -->
    <div id="bulkUploadModal" class="fixed inset-0 bg-black bg-opacity-75 hidden items-center justify-center z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md mx-4">
            <h3 class="text-xl font-bold mb-4">Upload Videos</h3>
            <p id="bulkFileCount" class="text-gray-400 mb-4">0 videos selected</p>
            <div class="space-y-4">
                <div>
                    <label class="block text-gray-300 mb-2">Category *</label>
                    <select id="modalCategory" required
                        class="w-full px-4 py-2 rounded-lg bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-purple-500"
                        onchange="updateModalSubcategories()">
                        <option value="">Select category</option>
                        {% for cat_id, cat in categories.items() %}
                        <option value="{{ cat_id }}">{{ cat.abbrev }} - {{ cat.name }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div id="modalSubcategoryDiv" class="hidden">
                    <label class="block text-gray-300 mb-2">Subcategory</label>
                    <select id="modalSubcategory"
                        class="w-full px-4 py-2 rounded-lg bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-purple-500">
                        <option value="">All / None</option>
                    </select>
                </div>
                <div>
                    <label class="block text-gray-300 mb-2">Event</label>
                    <input type="text" id="modalEvent" list="modalEventList"
                        class="w-full px-4 py-2 rounded-lg bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-purple-500"
                        placeholder="e.g., 2024 Nationals">
                    <datalist id="modalEventList">
                        {% for event in events %}
                        <option value="{{ event }}">
                        {% endfor %}
                    </datalist>
                </div>
                <div id="modalProgress" class="hidden"></div>
                <div id="modalMessage" class="hidden"></div>
                <div class="flex gap-3">
                    <button type="button" onclick="closeBulkUploadModal()"
                        class="flex-1 bg-gray-600 hover:bg-gray-500 py-3 rounded-lg font-semibold transition">
                        Cancel
                    </button>
                    <button type="button" onclick="confirmBulkUpload()"
                        class="flex-1 bg-purple-600 hover:bg-purple-700 py-3 rounded-lg font-semibold transition">
                        Upload Videos
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Edit Modal -->
    <div id="editModal" class="fixed inset-0 bg-black bg-opacity-75 hidden items-center justify-center z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-lg mx-4 max-h-[90vh] overflow-y-auto">
            <h3 class="text-xl font-bold mb-4">Edit Video</h3>
            <form id="editVideoForm" class="space-y-4">
                <input type="hidden" id="editVideoId">
                <div>
                    <label class="block text-gray-300 mb-2">Title *</label>
                    <input type="text" id="editTitle" required
                        class="w-full px-4 py-2 rounded-lg bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-purple-500">
                </div>
                <div>
                    <label class="block text-gray-300 mb-2">Video URL *</label>
                    <input type="url" id="editUrl" required
                        class="w-full px-4 py-2 rounded-lg bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-purple-500">
                </div>
                <div>
                    <label class="block text-gray-300 mb-2">Category *</label>
                    <select id="editCategory" required
                        class="w-full px-4 py-2 rounded-lg bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-purple-500"
                        onchange="updateEditSubcategories()">
                        {% for cat_id, cat in categories.items() %}
                        <option value="{{ cat_id }}">{{ cat.abbrev }} - {{ cat.name }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div id="editSubcategoryDiv" class="hidden">
                    <label class="block text-gray-300 mb-2">Subcategory</label>
                    <select id="editSubcategory"
                        class="w-full px-4 py-2 rounded-lg bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-purple-500">
                        <option value="">Select subcategory</option>
                    </select>
                </div>
                <div>
                    <label class="block text-gray-300 mb-2">Event</label>
                    <input type="text" id="editEvent" list="editEventList"
                        class="w-full px-4 py-2 rounded-lg bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-purple-500"
                        placeholder="e.g., 2024 Nationals">
                    <datalist id="editEventList">
                        {% for event in events %}
                        <option value="{{ event }}">
                        {% endfor %}
                    </datalist>
                </div>
                <div>
                    <label class="block text-gray-300 mb-2">Description</label>
                    <textarea id="editDescription" rows="3"
                        class="w-full px-4 py-2 rounded-lg bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-purple-500"></textarea>
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-gray-300 mb-2">Duration</label>
                        <input type="text" id="editDuration"
                            class="w-full px-4 py-2 rounded-lg bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-purple-500">
                    </div>
                    <div>
                        <label class="block text-gray-300 mb-2">Tags</label>
                        <input type="text" id="editTags"
                            class="w-full px-4 py-2 rounded-lg bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-purple-500">
                    </div>
                </div>
                <div class="flex gap-3">
                    <button type="button" onclick="closeEditModal()"
                        class="flex-1 bg-gray-600 hover:bg-gray-500 py-3 rounded-lg font-semibold transition">
                        Cancel
                    </button>
                    <button type="submit"
                        class="flex-1 bg-purple-600 hover:bg-purple-700 py-3 rounded-lg font-semibold transition">
                        Save Changes
                    </button>
                </div>
            </form>
        </div>
    </div>

    <script>
        const categories = {{ categories | tojson }};
        let pendingFiles = []; // Store files selected from Dropbox
        let s3Enabled = false;
        let s3Bucket = null;

        // Upload queue system
        let uploadQueue = [];
        let isUploading = false;

        function showQueuedNotification(count) {
            const toast = document.createElement('div');
            toast.className = 'fixed top-20 right-4 bg-green-600 text-white px-6 py-3 rounded-lg shadow-lg z-50 animate-pulse';
            toast.innerHTML = `‚úì ${count} file${count > 1 ? 's' : ''} queued - will upload after current batch`;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // FFmpeg for browser-based conversion
        let ffmpeg = null;
        let ffmpegLoaded = false;
        const needsConversion = ['.mkv', '.avi', '.mts', '.m2ts', '.wmv', '.flv', '.3gp'];

        async function initFFmpeg() {
            if (ffmpegLoaded) return true;

            try {
                // Check if FFmpeg is available (0.11.x API)
                if (typeof FFmpeg === 'undefined' || typeof FFmpeg.createFFmpeg !== 'function') {
                    console.error('FFmpeg library not loaded');
                    alert('Video converter not available. Please refresh the page and try again.');
                    return false;
                }

                const statusEl = document.getElementById('conversionStatus');
                if (statusEl) statusEl.textContent = 'Loading converter (this may take a moment)...';

                ffmpeg = FFmpeg.createFFmpeg({
                    log: true,
                    progress: ({ ratio }) => {
                        const pct = Math.round(ratio * 100);
                        const statusEl = document.getElementById('conversionStatus');
                        if (statusEl) statusEl.textContent = `Converting: ${pct}%`;
                    }
                });

                await ffmpeg.load();

                ffmpegLoaded = true;
                console.log('FFmpeg loaded successfully');
                return true;
            } catch (err) {
                console.error('FFmpeg failed to load:', err);
                alert('Failed to load video converter: ' + err.message);
                return false;
            }
        }

        async function convertToMp4(file) {
            if (!ffmpegLoaded) {
                const loaded = await initFFmpeg();
                if (!loaded) return null;
            }

            const inputName = 'input' + file.name.substring(file.name.lastIndexOf('.'));
            const outputName = file.name.replace(/\.[^/.]+$/, '') + '.mp4';

            try {
                console.log('Converting:', file.name);
                // Use FFmpeg.fetchFile for 0.11.x API
                const fileData = await FFmpeg.fetchFile(file);
                console.log('File loaded, size:', fileData.length);
                ffmpeg.FS('writeFile', inputName, fileData);
                console.log('Starting conversion...');
                await ffmpeg.run('-i', inputName, '-c:v', 'libx264', '-preset', 'ultrafast', '-crf', '28', '-c:a', 'aac', '-b:a', '128k', outputName);
                console.log('Conversion done, reading output...');
                const data = ffmpeg.FS('readFile', outputName);

                // Clean up
                ffmpeg.FS('unlink', inputName);
                ffmpeg.FS('unlink', outputName);

                return new File([data.buffer], outputName, { type: 'video/mp4' });
            } catch (err) {
                console.error('Conversion failed:', err);
                return null;
            }
        }

        function fileNeedsConversion(filename) {
            const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            return needsConversion.includes(ext);
        }

        // Check S3 status on page load
        async function checkS3Status() {
            try {
                const response = await fetch('/admin/s3-status');
                const result = await response.json();
                s3Enabled = result.enabled;
                s3Bucket = result.bucket;

                if (s3Enabled) {
                    document.getElementById('uploadDestinationLabel').textContent = 'AWS S3';
                    document.getElementById('uploadDestinationLabel').classList.remove('text-blue-400');
                    document.getElementById('uploadDestinationLabel').classList.add('text-green-400');
                } else {
                    document.getElementById('s3StatusBanner').classList.remove('hidden');
                }
            } catch (err) {
                console.log('S3 status check failed:', err);
            }
        }
        checkS3Status();

        // File Upload
        function updateUploadSubcategories() {
            const catId = document.getElementById('uploadCategory').value;
            const subDiv = document.getElementById('uploadSubcategoryDiv');
            const subSelect = document.getElementById('uploadSubcategory');

            const cat = categories[catId];
            if (cat && cat.subcategories && cat.subcategories.length > 0) {
                subSelect.innerHTML = '<option value="">Select</option>';
                cat.subcategories.forEach(sub => {
                    subSelect.innerHTML += `<option value="${sub.id}">${sub.name}</option>`;
                });
                subDiv.classList.remove('hidden');
            } else {
                subDiv.classList.add('hidden');
                subSelect.value = '';
            }
        }

        // ============================================
        // EXPORT VIDEO URLs FUNCTIONS
        // ============================================

        let uploadFolderName = '';

        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('border-purple-500', 'bg-gray-700');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('border-purple-500', 'bg-gray-700');
        }

        async function handleDrop(e) {
            e.preventDefault();
            const dropZone = e.currentTarget;
            dropZone.classList.remove('border-purple-500', 'bg-gray-700');

            const items = e.dataTransfer.items;
            let allFiles = []; // Each item: { file, event, category }

            // Show scanning indicator
            const originalContent = dropZone.innerHTML;
            dropZone.innerHTML = `
                <div class="flex flex-col items-center">
                    <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-purple-500 mb-4"></div>
                    <p class="text-purple-400 font-semibold">Scanning files...</p>
                    <p class="text-gray-500 text-sm mt-2" id="scanStatus">Reading folder contents</p>
                </div>
            `;
            dropZone.style.pointerEvents = 'none';

            try {
                // Check if any item is a directory
                if (items && items.length > 0) {
                    const entries = [];
                    for (let i = 0; i < items.length; i++) {
                        const entry = items[i].webkitGetAsEntry ? items[i].webkitGetAsEntry() : null;
                        if (entry) entries.push(entry);
                    }

                    // Process entries (files and folders)
                    for (const entry of entries) {
                        if (entry.isDirectory) {
                            // Main folder = event name
                            const eventName = entry.name;
                            document.getElementById('scanStatus').textContent = `Scanning folder: ${eventName}`;
                            const folderFiles = await readDirectoryFilesWithPath(entry, eventName, '');
                            allFiles = allFiles.concat(folderFiles);
                        } else if (entry.isFile) {
                            const file = await getFileFromEntry(entry);
                            if (file) allFiles.push({ file, event: '', category: '' });
                        }
                    }
                }

                // Fallback to regular file handling if no entries API
                if (allFiles.length === 0) {
                    allFiles = Array.from(e.dataTransfer.files).map(f => ({ file: f, event: '', category: '' }));
                }

                // Filter for video files
                const videoFiles = allFiles.filter(f => f.file.type.startsWith('video/') ||
                    f.file.name.toLowerCase().match(/\.(mp4|webm|mov|m4v|ogg|ogv|mts|m2ts|avi|mkv)$/));

                // Restore drop zone
                dropZone.innerHTML = originalContent;
                dropZone.style.pointerEvents = '';

                if (videoFiles.length > 0) {
                    // Add to queue instead of uploading directly
                    const wasUploading = isUploading;
                    uploadQueue.push(...videoFiles);
                    updateQueueStatus();

                    // Show brief notification if added during active upload
                    if (wasUploading) {
                        showQueuedNotification(videoFiles.length);
                    }

                    processUploadQueue();
                } else if (allFiles.length > 0) {
                    alert('No video files found in the dropped items');
                }
            } catch (error) {
                // Restore drop zone on error
                dropZone.innerHTML = originalContent;
                dropZone.style.pointerEvents = '';
                alert('Error scanning files: ' + error.message);
            }
        }

        function updateQueueStatus() {
            const progressDiv = document.getElementById('uploadProgress');
            let queueIndicator = document.getElementById('queueIndicator');

            if (uploadQueue.length > 0) {
                // Show queue indicator (works both during and outside of active upload)
                if (!queueIndicator) {
                    queueIndicator = document.createElement('div');
                    queueIndicator.id = 'queueIndicator';
                    progressDiv.parentNode.insertBefore(queueIndicator, progressDiv);
                }
                queueIndicator.innerHTML = `
                    <div class="bg-green-900/30 border border-green-600 rounded p-3 mb-2 flex items-center justify-between">
                        <div class="flex items-center gap-2">
                            <span class="text-green-400 font-semibold">üìÅ ${uploadQueue.length} files queued</span>
                            ${isUploading ? '<span class="text-gray-400 text-sm">- will process after current upload</span>' : ''}
                        </div>
                        <span class="text-green-500 text-xs">Drop more folders anytime!</span>
                    </div>
                `;
                queueIndicator.classList.remove('hidden');

                if (!isUploading) {
                    progressDiv.classList.remove('hidden');
                    progressDiv.innerHTML = `
                        <div class="bg-blue-900/30 border border-blue-600 rounded p-3 mb-2">
                            <span class="text-blue-400">${uploadQueue.length} files ready to upload</span>
                        </div>
                    `;
                }
            } else if (queueIndicator) {
                queueIndicator.classList.add('hidden');
            }
        }

        // Warn before leaving during upload
        window.addEventListener('beforeunload', function(e) {
            if (isUploading || uploadQueue.length > 0) {
                e.preventDefault();
                e.returnValue = 'Upload in progress. Are you sure you want to leave?';
                return e.returnValue;
            }
        });

        async function processUploadQueue() {
            if (isUploading || uploadQueue.length === 0) return;

            isUploading = true;
            const filesToUpload = [...uploadQueue];
            uploadQueue = [];

            await uploadFilesWithMetadata(filesToUpload);

            isUploading = false;

            // Check if more files were added while uploading
            if (uploadQueue.length > 0) {
                processUploadQueue();
            }
        }

        // Read directory files with path tracking for event/category
        async function readDirectoryFilesWithPath(dirEntry, eventName, categoryName) {
            const files = [];
            const reader = dirEntry.createReader();

            const readEntries = () => new Promise((resolve, reject) => {
                reader.readEntries(resolve, reject);
            });

            let entries;
            do {
                entries = await readEntries();
                for (const entry of entries) {
                    if (entry.isFile) {
                        const file = await getFileFromEntry(entry);
                        if (file) {
                            files.push({ file, event: eventName, category: categoryName });
                        }
                    } else if (entry.isDirectory) {
                        // Subfolder = category (if we don't have one yet)
                        // Sub-subfolder = keep same event/category
                        const subCategory = categoryName || entry.name;
                        const subFiles = await readDirectoryFilesWithPath(entry, eventName, subCategory);
                        files.push(...subFiles);
                    }
                }
            } while (entries.length > 0);

            return files;
        }

        // Helper to get File object from FileEntry
        function getFileFromEntry(entry) {
            return new Promise((resolve) => {
                entry.file(resolve, () => resolve(null));
            });
        }

        function handleFileSelect(e) {
            const files = Array.from(e.target.files);
            if (files.length > 0) {
                // Filter for video files
                const videoFiles = files.filter(f => f.type.startsWith('video/') ||
                    f.name.toLowerCase().match(/\.(mp4|webm|mov|m4v|ogg|ogv|mts|m2ts|avi|mkv)$/));

                if (videoFiles.length > 0) {
                    const wasUploading = isUploading;
                    // Convert to new format with empty metadata
                    const filesWithMeta = videoFiles.map(f => ({ file: f, event: '', category: '' }));
                    uploadQueue.push(...filesWithMeta);
                    updateQueueStatus();

                    if (wasUploading) {
                        showQueuedNotification(videoFiles.length);
                    }

                    processUploadQueue();
                }
            }
        }

        // Check if filename has recognizable team/round pattern
        function detectLabelFormat(filename) {
            // Remove extension
            const name = filename.replace(/\.[^/.]+$/, '');

            // Check for common patterns
            // USPA format: Year+CompName_Event-Class_TeamNum-TeamName_Round
            // e.g., 2024USPAOpenNationalChampionships_Freeflying-Open_6001-ZJDescend_1
            if (/^[^_]+_[^_]+-[^_]+_\d+-[^_]+_\d+$/.test(name)) return 'uspa_competition';
            if (/\d+\s+\d+/.test(name)) return 'team_space_round';  // "226 5"
            if (/\d+_\d+/.test(name)) return 'team_underscore_round';  // "226_5"
            if (/\d+-\d+/.test(name)) return 'team_dash_round';  // "226-5"
            if (/round\s*\d+/i.test(name)) return 'round_only';  // "Round 5"
            if (/\d+/.test(name)) return 'has_numbers';  // Has some numbers
            return 'unknown';
        }

        // Get custom label format from user
        async function getCustomLabelFormat(filename) {
            return new Promise((resolve) => {
                const format = prompt(
                    `Can't auto-detect labeling format for:\n"${filename}"\n\n` +
                    `Enter the format (or cancel to skip):\n` +
                    `1 = Team Round (e.g., 226 5)\n` +
                    `2 = Team_Round (e.g., 226_5)\n` +
                    `3 = Team-Round (e.g., 226-5)\n` +
                    `4 = Round only\n` +
                    `5 = USPA Competition (CompName_Event-Class_Team-Name_Round)\n` +
                    `6 = No team/round info`,
                    '1'
                );

                const formats = {
                    '1': 'team_space_round',
                    '2': 'team_underscore_round',
                    '3': 'team_dash_round',
                    '4': 'round_only',
                    '5': 'uspa_competition',
                    '6': 'none'
                };
                resolve(formats[format] || 'auto');
            });
        }

        async function uploadFilesWithMetadata(filesWithMeta) {
            const manualCategory = document.getElementById('uploadCategory').value;
            const manualSubcategory = document.getElementById('uploadSubcategory').value;
            const manualEvent = document.getElementById('uploadEvent').value;
            let labelFormat = document.getElementById('uploadLabelFormat').value;

            const progressDiv = document.getElementById('uploadProgress');
            const resultsDiv = document.getElementById('uploadResults');
            progressDiv.classList.remove('hidden');
            resultsDiv.classList.add('hidden');

            let uploaded = 0;
            let failed = 0;
            let converted = 0;
            let backgroundJobs = 0;
            const results = [];

            // If custom format selected, ask for first file and use for all
            if (labelFormat === 'custom' && filesWithMeta.length > 0) {
                const detected = detectLabelFormat(filesWithMeta[0].file.name);
                if (detected === 'unknown' || detected === 'has_numbers') {
                    labelFormat = await getCustomLabelFormat(filesWithMeta[0].file.name);
                } else {
                    labelFormat = detected;
                }
            }

            for (let i = 0; i < filesWithMeta.length; i++) {
                let { file, event: fileEvent, category: fileCategory } = filesWithMeta[i];

                // Use folder-detected values, or fall back to manual inputs
                const eventToUse = fileEvent || manualEvent;
                const categoryToUse = fileCategory || manualCategory;
                const willAutoDetect = !categoryToUse;

                // Files that need conversion will be handled by the server
                const willConvert = fileNeedsConversion(file.name);

                const queueInfo = uploadQueue.length > 0 ? `<span class="text-blue-400 ml-2">(${uploadQueue.length} more queued)</span>` : '';
                progressDiv.innerHTML = `
                    <div class="flex items-center gap-3">
                        <div class="animate-spin rounded-full h-5 w-5 border-b-2 border-purple-500"></div>
                        <span>Uploading ${i + 1}/${filesWithMeta.length}: ${file.name}</span>
                        ${queueInfo}
                    </div>
                    <div class="mt-2 text-sm text-gray-400">
                        ${uploaded} uploaded, ${failed} failed${converted > 0 ? `, ${converted} converted` : ''}
                        ${eventToUse ? `<span class="text-cyan-400 ml-2">Event: ${eventToUse}</span>` : ''}
                        ${categoryToUse ? `<span class="text-green-400 ml-2">Category: ${categoryToUse}</span>` : ''}
                        ${willAutoDetect ? `<span class="text-yellow-400 ml-2">Auto-detecting from filename...</span>` : ''}
                    </div>
                    <p class="text-gray-500 text-xs mt-2">You can drop more folders - they will be queued. Open in new tab to browse while uploading.</p>
                `;

                const formData = new FormData();
                formData.append('file', file);
                formData.append('category', categoryToUse || '');  // Empty string triggers auto-detect
                formData.append('subcategory', manualSubcategory);
                formData.append('event', eventToUse);
                formData.append('title', file.name.replace(/\.[^/.]+$/, '').replace(/[_-]/g, ' '));
                formData.append('background', 'true');
                // Always send folder_name if we have one - helps with detection
                if (fileCategory) {
                    formData.append('folder_name', fileCategory);
                }
                // Send label format for team/round parsing
                if (labelFormat && labelFormat !== 'auto') {
                    formData.append('label_format', labelFormat);
                }

                const ext = file.name.split('.').pop().toLowerCase();
                const s3DirectExtensions = ['mp4', 'webm', 'mov', 'm4v', 'ogg', 'ogv']; // Files that can go direct to S3
                const needsConversion = ['mkv', 'mts', 'm2ts', 'avi'].includes(ext);

                try {
                    // Use direct S3 upload only for web-compatible formats (not MKV/AVI that need conversion)
                    if (s3Enabled && s3DirectExtensions.includes(ext)) {
                        // Step 1: Get presigned URL
                        const presignedResponse = await fetch('/admin/s3-presigned-upload', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                filename: file.name,
                                content_type: file.type || 'video/mp4',
                                category: categoryToUse || '',
                                subcategory: manualSubcategory,
                                title: file.name.replace(/\.[^/.]+$/, '').replace(/[_-]/g, ' '),
                                event: eventToUse
                            })
                        });
                        const presignedResult = await presignedResponse.json();

                        if (!presignedResult.success) {
                            throw new Error(presignedResult.error || 'Failed to get upload URL');
                        }

                        // Step 2: Upload directly to S3 using fetch
                        const mbTotal = (file.size / 1024 / 1024).toFixed(1);
                        progressDiv.innerHTML = `
                            <div class="flex items-center gap-3">
                                <div class="animate-spin rounded-full h-5 w-5 border-b-2 border-purple-500"></div>
                                <span>Uploading ${i + 1}/${filesWithMeta.length}: ${file.name} (${mbTotal} MB)</span>
                            </div>
                            <div class="mt-1 text-sm text-gray-400">Uploading to S3... (this may take a moment)</div>
                        `;

                        const s3Response = await fetch(presignedResult.presigned_url, {
                            method: 'PUT',
                            body: file
                        });

                        if (!s3Response.ok) {
                            throw new Error(`S3 upload failed: ${s3Response.status} ${s3Response.statusText}`);
                        }

                        // Step 3: Notify server that upload is complete
                        const completeResponse = await fetch('/admin/s3-upload-complete', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                video_id: presignedResult.video_id,
                                s3_key: presignedResult.s3_key,
                                final_url: presignedResult.final_url,
                                filename: file.name,
                                title: file.name.replace(/\.[^/.]+$/, '').replace(/[_-]/g, ' '),
                                category: categoryToUse || '',
                                subcategory: manualSubcategory,
                                event: eventToUse,
                                needs_conversion: needsConversion
                            })
                        });
                        const completeResult = await completeResponse.json();

                        if (completeResult.success) {
                            if (completeResult.converting) {
                                backgroundJobs++;
                                results.push({ name: file.name, success: true, background: true, s3: true });
                                startConversionPolling();
                            } else {
                                uploaded++;
                                results.push({ name: file.name, success: true, s3: true });
                            }
                        } else {
                            failed++;
                            results.push({ name: file.name, success: false, error: completeResult.error });
                        }
                    } else {
                        // Use chunked upload for files that need conversion (MKV, AVI, etc.)
                        const CHUNK_SIZE = 5 * 1024 * 1024; // 5MB chunks
                        const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
                        const uploadId = Date.now().toString(36) + Math.random().toString(36).substr(2);
                        const mbTotal = (file.size / 1024 / 1024).toFixed(1);

                        let uploadedChunks = 0;
                        let chunkFailed = false;

                        // Upload each chunk
                        for (let chunkIndex = 0; chunkIndex < totalChunks && !chunkFailed; chunkIndex++) {
                            const start = chunkIndex * CHUNK_SIZE;
                            const end = Math.min(start + CHUNK_SIZE, file.size);
                            const chunk = file.slice(start, end);

                            const percent = Math.round((chunkIndex / totalChunks) * 100);
                            const mbUploaded = (start / 1024 / 1024).toFixed(1);
                            progressDiv.innerHTML = `
                                <div class="flex items-center gap-3">
                                    <div class="animate-spin rounded-full h-5 w-5 border-b-2 border-purple-500"></div>
                                    <span>Uploading ${i + 1}/${filesWithMeta.length}: ${file.name}</span>
                                </div>
                                <div class="mt-2 bg-gray-700 rounded-full h-2 overflow-hidden">
                                    <div class="bg-green-500 h-full transition-all" style="width: ${percent}%"></div>
                                </div>
                                <div class="mt-1 text-sm text-gray-400">${percent}% (${mbUploaded}/${mbTotal} MB) - Chunk ${chunkIndex + 1}/${totalChunks}</div>
                            `;

                            const chunkFormData = new FormData();
                            chunkFormData.append('chunk', chunk);
                            chunkFormData.append('upload_id', uploadId);
                            chunkFormData.append('chunk_index', chunkIndex);
                            chunkFormData.append('total_chunks', totalChunks);
                            chunkFormData.append('filename', file.name);

                            try {
                                const chunkResponse = await fetch('/admin/upload-chunk', {
                                    method: 'POST',
                                    body: chunkFormData
                                });
                                const chunkResult = await chunkResponse.json();
                                if (!chunkResult.success) {
                                    chunkFailed = true;
                                    failed++;
                                    results.push({ name: file.name, success: false, error: chunkResult.error || 'Chunk upload failed' });
                                } else {
                                    uploadedChunks++;
                                }
                            } catch (chunkError) {
                                chunkFailed = true;
                                failed++;
                                results.push({ name: file.name, success: false, error: 'Chunk upload error: ' + chunkError.message });
                            }
                        }

                        // If all chunks uploaded, complete the upload
                        if (!chunkFailed && uploadedChunks === totalChunks) {
                            progressDiv.innerHTML = `
                                <div class="flex items-center gap-3">
                                    <div class="animate-spin rounded-full h-5 w-5 border-b-2 border-purple-500"></div>
                                    <span>Assembling ${file.name}...</span>
                                </div>
                            `;

                            const completeResponse = await fetch('/admin/upload-chunk-complete', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    upload_id: uploadId,
                                    filename: file.name,
                                    title: file.name.replace(/\.[^/.]+$/, '').replace(/[_-]/g, ' '),
                                    category: categoryToUse || '',
                                    subcategory: manualSubcategory,
                                    event: eventToUse
                                })
                            });
                            const completeResult = await completeResponse.json();

                            if (completeResult.success) {
                                backgroundJobs++;
                                results.push({ name: file.name, success: true, background: true });
                                startConversionPolling();
                            } else {
                                failed++;
                                results.push({ name: file.name, success: false, error: completeResult.error });
                            }
                        }
                    }
                } catch (error) {
                    failed++;
                    const errorMsg = error.name === 'AbortError' ? 'Upload timeout' : error.message;
                    results.push({ name: file.name, success: false, error: errorMsg });
                }
            }

            progressDiv.classList.add('hidden');
            resultsDiv.classList.remove('hidden');

            let statusMsg = '';
            if (uploaded > 0) statusMsg += `${uploaded} uploaded`;
            if (backgroundJobs > 0) statusMsg += `${statusMsg ? ', ' : ''}${backgroundJobs} converting`;
            if (failed > 0) statusMsg += `${statusMsg ? ', ' : ''}${failed} failed`;

            resultsDiv.innerHTML = `
                <div class="bg-gray-700 rounded-lg p-4">
                    <p class="font-semibold mb-2">${statusMsg}</p>
                    <div class="max-h-32 overflow-y-auto text-sm">
                        ${results.map(r => `
                            <div class="${r.success ? (r.background ? 'text-yellow-400' : 'text-green-400') : 'text-red-400'}">
                                ${r.success ? (r.background ? '‚è≥' : '‚úì') : '‚úó'} ${r.name} ${r.background ? '(converting...)' : ''} ${r.s3 ? '(S3)' : ''} ${r.error ? '- ' + r.error : ''}
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;

            if (uploaded > 0 || backgroundJobs > 0) {
                setTimeout(() => location.reload(), 2000);
            }
        }

        // Legacy function for backwards compatibility
        async function uploadFiles(files, folderName = '') {
            const category = document.getElementById('uploadCategory').value;
            const subcategory = document.getElementById('uploadSubcategory').value;
            const event = document.getElementById('uploadEvent').value;

            // Category is optional - will default to 'uncategorized' or auto-detect from folder name

            const progressDiv = document.getElementById('uploadProgress');
            const resultsDiv = document.getElementById('uploadResults');
            progressDiv.classList.remove('hidden');
            resultsDiv.classList.add('hidden');

            let uploaded = 0;
            let failed = 0;
            let backgroundJobs = 0;
            const results = [];

            // Upload files one at a time for reliable progress tracking
            for (let i = 0; i < files.length; i++) {
                const file = files[i];

                progressDiv.innerHTML = `
                    <div class="flex items-center gap-3">
                        <div class="animate-spin rounded-full h-5 w-5 border-b-2 border-purple-500"></div>
                        <span>Uploading ${i + 1}/${files.length}: ${file.name}</span>
                    </div>
                    <div class="mt-2 text-sm text-gray-400">
                        ${uploaded} uploaded, ${failed} failed
                    </div>
                `;

                const formData = new FormData();
                formData.append('file', file);
                formData.append('category', category);
                formData.append('subcategory', subcategory);
                formData.append('event', event);
                formData.append('title', file.name.replace(/\.[^/.]+$/, '').replace(/[_-]/g, ' '));
                formData.append('background', 'true');
                if (folderName) {
                    formData.append('folder_name', folderName);
                }

                // Choose upload endpoint based on S3 status
                const ext = file.name.split('.').pop().toLowerCase();
                const s3Compatible = ['mp4', 'webm', 'mov', 'm4v', 'ogg', 'ogv'].includes(ext);
                const uploadUrl = (s3Enabled && s3Compatible) ? '/admin/upload-to-s3' : '/admin/upload-video';

                try {
                    // 2 minute timeout per file
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 120000);

                    const response = await fetch(uploadUrl, {
                        method: 'POST',
                        body: formData,
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);

                    const result = await response.json();

                    if (result.success) {
                        if (result.background) {
                            backgroundJobs++;
                            results.push({ name: file.name, success: true, background: true, jobId: result.job_id });
                            startConversionPolling();
                        } else {
                            uploaded++;
                            results.push({ name: file.name, success: true, converted: result.converted, s3: s3Enabled && s3Compatible });
                        }
                    } else {
                        failed++;
                        results.push({ name: file.name, success: false, error: result.error });
                    }
                } catch (error) {
                    failed++;
                    const errorMsg = error.name === 'AbortError' ? 'Upload timeout (2 min)' : error.message;
                    results.push({ name: file.name, success: false, error: errorMsg });
                }
            }

            progressDiv.classList.add('hidden');
            resultsDiv.classList.remove('hidden');

            let statusMsg = '';
            if (uploaded > 0) statusMsg += `${uploaded} uploaded`;
            if (backgroundJobs > 0) statusMsg += `${statusMsg ? ', ' : ''}${backgroundJobs} converting in background`;
            if (failed > 0) statusMsg += `${statusMsg ? ', ' : ''}${failed} failed`;

            resultsDiv.innerHTML = `
                <div class="bg-gray-700 rounded-lg p-4">
                    <p class="font-semibold mb-2">${statusMsg}</p>
                    <div class="max-h-32 overflow-y-auto text-sm">
                        ${results.map(r => `
                            <div class="${r.success ? (r.background ? 'text-yellow-400' : 'text-green-400') : 'text-red-400'}">
                                ${r.success ? (r.background ? '‚è≥' : '‚úì') : '‚úó'} ${r.name} ${r.background ? '(converting...)' : ''} ${r.converted ? '(converted)' : ''} ${r.s3 ? '(S3)' : ''} ${r.error ? '- ' + r.error : ''}
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;

            // Only auto-reload if there were direct uploads and no background jobs
            if (uploaded > 0 && backgroundJobs === 0) {
                setTimeout(() => location.reload(), 2000);
            }
        }

        // Fix Duplicates
        async function fixDuplicates() {
            const msgDiv = document.getElementById('fixDuplicatesMessage');
            msgDiv.textContent = 'Scanning for duplicates...';
            msgDiv.className = 'text-sm mt-2 text-yellow-400';
            msgDiv.classList.remove('hidden');

            try {
                const response = await fetch('/admin/fix-duplicates', { method: 'POST' });
                const result = await response.json();

                if (result.success) {
                    msgDiv.textContent = result.message;
                    msgDiv.className = 'text-sm mt-2 text-green-400';
                    if (result.removed > 0) {
                        setTimeout(() => location.reload(), 2000);
                    }
                } else {
                    msgDiv.textContent = result.error || 'Error fixing duplicates';
                    msgDiv.className = 'text-sm mt-2 text-red-400';
                }
            } catch (error) {
                msgDiv.textContent = 'Error: ' + error.message;
                msgDiv.className = 'text-sm mt-2 text-red-400';
            }
        }

        // Scan Durations
        let durationScanInterval = null;

        async function scanDurations() {
            const btn = document.getElementById('scanDurationsBtn');
            const msgDiv = document.getElementById('scanDurationsMessage');

            btn.disabled = true;
            btn.textContent = 'Starting...';
            msgDiv.textContent = 'Starting duration scan...';
            msgDiv.className = 'text-sm mt-2 text-yellow-400';
            msgDiv.classList.remove('hidden');

            try {
                const response = await fetch('/admin/scan-durations', { method: 'POST' });
                const result = await response.json();

                if (result.success) {
                    btn.textContent = 'Scanning...';
                    // Start polling for status
                    durationScanInterval = setInterval(checkDurationScanStatus, 2000);
                    checkDurationScanStatus();
                } else {
                    msgDiv.textContent = result.error || 'Error starting scan';
                    msgDiv.className = 'text-sm mt-2 text-red-400';
                    btn.disabled = false;
                    btn.textContent = 'Scan Durations';
                }
            } catch (error) {
                msgDiv.textContent = 'Error: ' + error.message;
                msgDiv.className = 'text-sm mt-2 text-red-400';
                btn.disabled = false;
                btn.textContent = 'Scan Durations';
            }
        }

        async function checkDurationScanStatus() {
            const btn = document.getElementById('scanDurationsBtn');
            const msgDiv = document.getElementById('scanDurationsMessage');

            try {
                const response = await fetch('/admin/scan-durations/status');
                const status = await response.json();

                if (status.running) {
                    msgDiv.textContent = `Scanning ${status.current}/${status.total}: ${status.current_video}... (${status.updated} updated, ${status.skipped} skipped, ${status.failed} failed)`;
                    msgDiv.className = 'text-sm mt-2 text-yellow-400';
                } else {
                    // Scan complete
                    clearInterval(durationScanInterval);
                    msgDiv.textContent = `Complete: ${status.updated} updated, ${status.skipped} already had duration, ${status.failed} failed`;
                    msgDiv.className = 'text-sm mt-2 text-green-400';
                    btn.disabled = false;
                    btn.textContent = 'Scan Durations';
                }
            } catch (error) {
                console.error('Error checking scan status:', error);
            }
        }

        // Check if scan is already running on page load
        checkDurationScanStatus();

        let thumbsProcessed = 0;
        let thumbsTotal = 0;
        let thumbsRunning = false;

        function stopThumbnailGeneration() {
            thumbsRunning = false;
            const btn = document.getElementById('refreshThumbsBtn');
            const stopBtn = document.getElementById('stopThumbsBtn');
            const msgDiv = document.getElementById('refreshThumbsMessage');

            btn.disabled = false;
            btn.textContent = 'Resume';
            stopBtn.classList.add('hidden');
            msgDiv.textContent = `Stopped. ${thumbsProcessed} thumbnails generated so far.`;
            msgDiv.className = 'text-sm mt-2 text-yellow-400';
        }

        async function refreshThumbnails(autoContinue = true) {
            const btn = document.getElementById('refreshThumbsBtn');
            const stopBtn = document.getElementById('stopThumbsBtn');
            const msgDiv = document.getElementById('refreshThumbsMessage');
            const progressDiv = document.getElementById('refreshThumbsProgress');

            thumbsRunning = true;
            btn.disabled = true;
            btn.textContent = 'Generating...';
            stopBtn.classList.remove('hidden');
            msgDiv.textContent = 'Downloading videos and generating thumbnails...';
            msgDiv.className = 'text-sm mt-2 text-yellow-400';
            msgDiv.classList.remove('hidden');
            progressDiv.classList.remove('hidden');

            try {
                const response = await fetch('/admin/refresh-thumbnails', { method: 'POST' });
                const result = await response.json();

                if (result.success) {
                    thumbsProcessed += result.updated;
                    thumbsTotal = result.total_missing;

                    msgDiv.textContent = result.message;
                    msgDiv.className = 'text-sm mt-2 text-green-400';
                    progressDiv.textContent = `Total progress: ${thumbsProcessed} of ${thumbsTotal} thumbnails generated`;

                    if (result.errors && result.errors.length > 0) {
                        console.log('Thumbnail errors:', result.errors);
                    }

                    // Auto-continue if there are more to process and not stopped
                    if (result.remaining > 0 && thumbsRunning) {
                        btn.textContent = `Processing... (${result.remaining} left)`;
                        setTimeout(() => refreshThumbnails(true), 1000);
                    } else if (result.remaining > 0) {
                        btn.disabled = false;
                        btn.textContent = `Resume (${result.remaining} left)`;
                        stopBtn.classList.add('hidden');
                    } else {
                        btn.disabled = false;
                        btn.textContent = 'Generate Thumbnails';
                        stopBtn.classList.add('hidden');
                        msgDiv.textContent = `Done! Generated ${thumbsProcessed} thumbnails.`;
                        thumbsRunning = false;
                    }
                } else {
                    msgDiv.textContent = result.error || 'Error generating thumbnails';
                    msgDiv.className = 'text-sm mt-2 text-red-400';
                    if (result.trace) console.log('Error trace:', result.trace);
                    btn.disabled = false;
                    btn.textContent = 'Retry';
                    stopBtn.classList.add('hidden');
                    thumbsRunning = false;
                }
            } catch (error) {
                msgDiv.textContent = 'Error: ' + error.message;
                msgDiv.className = 'text-sm mt-2 text-red-400';
                btn.disabled = false;
                btn.textContent = 'Retry';
                stopBtn.classList.add('hidden');
                thumbsRunning = false;
            }
        }

        // Auto-categorize videos
        async function autoCategorize() {
            const btn = document.getElementById('autoCategorizeBtn');
            const msgDiv = document.getElementById('autoCategorizeMessage');
            const scope = document.getElementById('autoCategorizeScope').value;

            let adminPin = '';

            // If processing all files, require PIN
            if (scope === 'all') {
                adminPin = prompt('Enter admin PIN to re-categorize ALL files:\n\nWarning: This will overwrite existing categories!');
                if (!adminPin) {
                    msgDiv.textContent = 'Cancelled - PIN required for all files';
                    msgDiv.className = 'text-sm mt-2 text-yellow-400';
                    msgDiv.classList.remove('hidden');
                    return;
                }
            }

            btn.disabled = true;
            btn.textContent = 'Processing...';
            msgDiv.textContent = scope === 'all' ? 'Analyzing ALL files...' : 'Analyzing uncategorized files...';
            msgDiv.className = 'text-sm mt-2 text-yellow-400';
            msgDiv.classList.remove('hidden');

            try {
                const response = await fetch('/admin/auto-categorize', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        only_uncategorized: scope !== 'all',
                        admin_pin: adminPin
                    })
                });
                const result = await response.json();

                if (result.success) {
                    let message = result.message;
                    if (result.details && result.details.length > 0) {
                        message += '\n\nUpdated:';
                        result.details.slice(0, 10).forEach(d => {
                            message += `\n- ${d.title}: ${d.changes.join(', ')}`;
                        });
                        if (result.details.length > 10) {
                            message += `\n... and ${result.details.length - 10} more`;
                        }
                    }
                    msgDiv.textContent = result.message;
                    msgDiv.className = 'text-sm mt-2 text-green-400';

                    if (result.updated > 0) {
                        // Show details in a modal or alert
                        let detailsText = `Updated ${result.updated} video(s):\n\n`;
                        result.details.slice(0, 20).forEach(d => {
                            detailsText += `${d.title}:\n  ${d.changes.join('\n  ')}\n\n`;
                        });
                        if (result.details.length > 20) {
                            detailsText += `... and ${result.details.length - 20} more`;
                        }
                        alert(detailsText);
                        setTimeout(() => location.reload(), 1000);
                    }
                } else {
                    msgDiv.textContent = result.error || 'Error auto-categorizing';
                    msgDiv.className = 'text-sm mt-2 text-red-400';
                }
            } catch (error) {
                msgDiv.textContent = 'Error: ' + error.message;
                msgDiv.className = 'text-sm mt-2 text-red-400';
            }

            btn.disabled = false;
            btn.textContent = 'Auto-Categorize';
        }

        // Dropbox Chooser - Single file
        function chooseFromDropbox() {
            Dropbox.choose({
                success: function(files) {
                    // Check for formats that need conversion
                    const filename = files[0].name.toLowerCase();
                    const needsConversion = ['.mts', '.m2ts', '.avi', '.mkv', '.wmv', '.flv', '.3gp'].some(ext => filename.endsWith(ext));
                    if (needsConversion) {
                        if (!confirm('This file (' + files[0].name + ') needs to be converted to MP4.\n\nIf running locally, it will be downloaded and converted automatically.\nOn production, this will fail.\n\nSupported formats: MP4, WebM, OGG, MOV\n\nContinue?')) {
                            return;
                        }
                    }
                    // Convert to streaming URL (use dl.dropboxusercontent.com)
                    let url = files[0].link
                        .replace('www.dropbox.com', 'dl.dropboxusercontent.com')
                        .replace('?dl=0', '');
                    document.getElementById('videoUrl').value = url;

                    // Auto-fill title from filename
                    const title = document.getElementById('videoTitle');
                    if (!title.value) {
                        title.value = files[0].name.replace(/\.[^/.]+$/, '').replace(/[_-]/g, ' ');
                    }
                },
                linkType: 'direct',
                multiselect: false,
                extensions: ['video'],
                folderselect: false
            });
        }

        // Dropbox Chooser - Select files first, then choose category
        function chooseFolderFromDropbox() {
            Dropbox.choose({
                success: function(files) {
                    pendingFiles = files;
                    openBulkUploadModal(files.length);
                },
                linkType: 'direct',
                multiselect: true,
                extensions: ['video'],
                folderselect: false
            });
        }

        // Dropbox Chooser - Multiple files (same flow)
        function chooseMultipleFromDropbox() {
            Dropbox.choose({
                success: function(files) {
                    pendingFiles = files;
                    openBulkUploadModal(files.length);
                },
                linkType: 'direct',
                multiselect: true,
                extensions: ['video'],
                folderselect: false
            });
        }

        // Modal functions
        function openBulkUploadModal(fileCount) {
            document.getElementById('bulkFileCount').textContent = `${fileCount} video${fileCount !== 1 ? 's' : ''} selected`;
            document.getElementById('modalCategory').value = '';
            document.getElementById('modalSubcategory').value = '';
            document.getElementById('modalSubcategoryDiv').classList.add('hidden');
            document.getElementById('modalProgress').classList.add('hidden');
            document.getElementById('modalMessage').classList.add('hidden');
            document.getElementById('bulkUploadModal').classList.remove('hidden');
            document.getElementById('bulkUploadModal').classList.add('flex');
        }

        function closeBulkUploadModal() {
            document.getElementById('bulkUploadModal').classList.add('hidden');
            document.getElementById('bulkUploadModal').classList.remove('flex');
            pendingFiles = [];
        }

        function updateModalSubcategories() {
            const catId = document.getElementById('modalCategory').value;
            const subDiv = document.getElementById('modalSubcategoryDiv');
            const subSelect = document.getElementById('modalSubcategory');

            const cat = categories[catId];
            if (cat && cat.subcategories && cat.subcategories.length > 0) {
                subSelect.innerHTML = '<option value="">All / None</option>';
                cat.subcategories.forEach(sub => {
                    subSelect.innerHTML += `<option value="${sub.id}">${sub.name}</option>`;
                });
                subDiv.classList.remove('hidden');
            } else {
                subDiv.classList.add('hidden');
                subSelect.value = '';
            }
        }

        async function confirmBulkUpload() {
            const category = document.getElementById('modalCategory').value;
            const subcategory = document.getElementById('modalSubcategory').value;
            const event = document.getElementById('modalEvent').value;

            // Category is optional - will default to 'uncategorized'

            const progressDiv = document.getElementById('modalProgress');
            const messageDiv = document.getElementById('modalMessage');

            progressDiv.classList.remove('hidden');
            progressDiv.innerHTML = `<div class="flex items-center gap-3"><div class="animate-spin rounded-full h-5 w-5 border-b-2 border-green-500"></div><span>Adding 0/${pendingFiles.length} videos...</span></div>`;

            let added = 0;
            let errors = [];

            // Check for files that need conversion
            const conversionExts = ['.mts', '.m2ts', '.avi', '.mkv', '.wmv', '.flv', '.3gp'];
            const conversionFiles = pendingFiles.filter(f => {
                const name = f.name.toLowerCase();
                return conversionExts.some(ext => name.endsWith(ext));
            });
            if (conversionFiles.length > 0) {
                if (!confirm(conversionFiles.length + ' file(s) need conversion to MP4.\n\nSupported formats: MP4, WebM, OGG, MOV\nNeed conversion: MTS, AVI, MKV, WMV, FLV\n\nIf running locally, they will be converted automatically.\nOn production, these will fail.\n\nContinue?')) {
                    progressDiv.classList.add('hidden');
                    return;
                }
            }

            for (const file of pendingFiles) {
                const url = file.link.replace('www.dropbox.com', 'dl.dropboxusercontent.com').replace('?dl=0', '');
                const title = file.name.replace(/\.[^/.]+$/, '').replace(/[_-]/g, ' ');

                try {
                    const response = await fetch('/admin/add-video', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            title: title,
                            url: url,
                            category: category,
                            subcategory: subcategory,
                            description: '',
                            tags: '',
                            duration: '',
                            event: event
                        })
                    });

                    const result = await response.json();
                    if (result.success) {
                        added++;
                    } else {
                        errors.push(file.name);
                    }
                } catch (e) {
                    errors.push(file.name);
                }

                progressDiv.innerHTML = `<div class="flex items-center gap-3"><div class="animate-spin rounded-full h-5 w-5 border-b-2 border-green-500"></div><span>Adding ${added}/${pendingFiles.length} videos...</span></div>`;
            }

            progressDiv.classList.add('hidden');

            if (errors.length > 0) {
                messageDiv.className = 'bg-yellow-900 border border-yellow-700 text-yellow-200 px-4 py-3 rounded';
                messageDiv.textContent = `Added ${added} videos. Failed: ${errors.length}`;
            } else {
                messageDiv.className = 'bg-green-900 border border-green-700 text-green-200 px-4 py-3 rounded';
                messageDiv.textContent = `Successfully added ${added} videos!`;
            }
            messageDiv.classList.remove('hidden');

            setTimeout(() => location.reload(), 1500);
        }

        function updateBulkSubcategories() {
            const catId = document.getElementById('bulkCategory').value;
            const subDiv = document.getElementById('bulkSubcategoryDiv');
            const subSelect = document.getElementById('bulkSubcategory');

            const cat = categories[catId];
            if (cat && cat.subcategories && cat.subcategories.length > 0) {
                subSelect.innerHTML = '<option value="">All / None</option>';
                cat.subcategories.forEach(sub => {
                    subSelect.innerHTML += `<option value="${sub.id}">${sub.name}</option>`;
                });
                subDiv.classList.remove('hidden');
            } else {
                subDiv.classList.add('hidden');
                subSelect.value = '';
            }
        }

        function updateEditSubcategories() {
            const catId = document.getElementById('editCategory').value;
            const subDiv = document.getElementById('editSubcategoryDiv');
            const subSelect = document.getElementById('editSubcategory');

            const cat = categories[catId];
            if (cat && cat.subcategories && cat.subcategories.length > 0) {
                subSelect.innerHTML = '<option value="">Select subcategory</option>';
                cat.subcategories.forEach(sub => {
                    subSelect.innerHTML += `<option value="${sub.id}">${sub.name}</option>`;
                });
                subDiv.classList.remove('hidden');
            } else {
                subDiv.classList.add('hidden');
                subSelect.value = '';
            }
        }

        // Delete Video
        async function deleteVideo(videoId) {
            if (!confirm('Are you sure you want to delete this video?')) return;

            try {
                const response = await fetch(`/admin/delete-video/${videoId}`, { method: 'POST' });
                const result = await response.json();

                if (result.error) {
                    alert(result.error);
                } else {
                    location.reload();
                }
            } catch (error) {
                alert('Error deleting video: ' + error.message);
            }
        }

        // Quick rename video (inline)
        async function quickRenameVideo(videoId, newTitle) {
            if (!newTitle.trim()) return;
            try {
                const response = await fetch(`/admin/edit-video/${videoId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title: newTitle.trim() })
                });
                const result = await response.json();
                if (!result.success) {
                    alert(result.error || 'Failed to rename');
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }

        // Quick change category (inline)
        async function quickChangeCategory(videoId, newCategory, selectEl) {
            try {
                const response = await fetch(`/admin/edit-video/${videoId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ category: newCategory, subcategory: '' })
                });
                const result = await response.json();
                if (!result.success) {
                    alert(result.error || 'Failed to change category');
                } else {
                    // Update subcategory dropdown
                    const subSelect = selectEl.parentElement.querySelector('.subcategory-select');
                    const cat = categories[newCategory];
                    if (cat && cat.subcategories && cat.subcategories.length > 0) {
                        subSelect.innerHTML = '<option value="">--</option>';
                        cat.subcategories.forEach(sub => {
                            subSelect.innerHTML += `<option value="${sub.id}">${sub.name}</option>`;
                        });
                        subSelect.style.display = '';
                    } else {
                        subSelect.style.display = 'none';
                        subSelect.innerHTML = '<option value="">--</option>';
                    }
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }

        // Quick change subcategory (inline)
        async function quickChangeSubcategory(videoId, newSubcategory) {
            try {
                const response = await fetch(`/admin/edit-video/${videoId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ subcategory: newSubcategory })
                });
                const result = await response.json();
                if (!result.success) {
                    alert(result.error || 'Failed to change subcategory');
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }

        // Quick change event (inline)
        async function quickChangeEvent(videoId, newEvent) {
            try {
                const response = await fetch(`/admin/edit-video/${videoId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ event: newEvent })
                });
                const result = await response.json();
                if (!result.success) {
                    alert(result.error || 'Failed to change event');
                } else {
                    // Update data attribute
                    const videoEl = document.querySelector(`[data-video-id="${videoId}"]`);
                    if (videoEl) videoEl.dataset.event = newEvent;
                    // Re-apply filter to update view
                    filterVideosByEvent();
                }
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }

        // Filter videos by event
        function filterVideosByEvent() {
            const filterValue = document.getElementById('filterEventSelect').value;
            const videos = document.querySelectorAll('.video-list-item');
            let visibleCount = 0;

            videos.forEach(video => {
                const videoEvent = video.dataset.event || '';
                let show = true;

                if (filterValue === '__none__') {
                    show = !videoEvent;  // Show only videos with no event
                } else if (filterValue) {
                    show = videoEvent === filterValue;
                }

                video.style.display = show ? '' : 'none';
                if (show) visibleCount++;
            });

            document.getElementById('videoFilterCount').textContent = `${visibleCount} video${visibleCount !== 1 ? 's' : ''} shown`;
        }

        // Bulk assign event to visible videos
        async function bulkAssignEvent() {
            const newEvent = document.getElementById('bulkEventInput').value.trim();
            if (!newEvent) {
                alert('Please enter an event name');
                return;
            }

            const visibleVideos = document.querySelectorAll('.video-list-item:not([style*="display: none"])');
            if (visibleVideos.length === 0) {
                alert('No visible videos to assign');
                return;
            }

            if (!confirm(`Assign "${newEvent}" to ${visibleVideos.length} video(s)?`)) {
                return;
            }

            let success = 0;
            let failed = 0;

            for (const video of visibleVideos) {
                const videoId = video.dataset.videoId;
                try {
                    const response = await fetch(`/admin/edit-video/${videoId}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ event: newEvent })
                    });
                    const result = await response.json();
                    if (result.success) {
                        success++;
                        video.dataset.event = newEvent;
                        const eventInput = video.querySelector('.event-input');
                        if (eventInput) eventInput.value = newEvent;
                    } else {
                        failed++;
                    }
                } catch (e) {
                    failed++;
                }
            }

            alert(`Done! ${success} updated, ${failed} failed.`);
            // Re-apply filter to hide moved videos
            filterVideosByEvent();
        }

        // Sort videos by team number, then round number
        function sortByTeamRound() {
            const container = document.getElementById('videoListContainer');
            const videos = Array.from(container.querySelectorAll('.video-list-item'));

            // Parse team and round from title
            // Format: "3 168 4001 10" - last two numbers are team (4001) and round (10)
            // Also handles "453 4" format
            function parseTeamRound(title) {
                const nums = title.match(/\d+/g);
                if (nums && nums.length >= 2) {
                    // Take the last two numbers as team and round
                    const team = parseInt(nums[nums.length - 2]);
                    const round = parseInt(nums[nums.length - 1]);
                    return { team, round };
                } else if (nums && nums.length === 1) {
                    return { team: parseInt(nums[0]), round: 0 };
                }
                return { team: 999999, round: 999999 };
            }

            videos.sort((a, b) => {
                const titleA = a.querySelector('input[type="text"]')?.value || '';
                const titleB = b.querySelector('input[type="text"]')?.value || '';

                const parsedA = parseTeamRound(titleA);
                const parsedB = parseTeamRound(titleB);

                // Sort by team first, then by round
                if (parsedA.team !== parsedB.team) {
                    return parsedA.team - parsedB.team;
                }
                return parsedA.round - parsedB.round;
            });

            // Re-append in sorted order
            videos.forEach(video => container.appendChild(video));

            document.getElementById('videoFilterCount').textContent = 'Sorted by team/round';
        }

        // Edit Video - fetch data and open modal
        async function editVideo(videoId) {
            try {
                const response = await fetch(`/admin/get-video/${videoId}`);
                const video = await response.json();

                if (video.error) {
                    alert(video.error);
                    return;
                }

                // Populate form fields
                document.getElementById('editVideoId').value = video.id;
                document.getElementById('editTitle').value = video.title || '';
                document.getElementById('editUrl').value = video.url || '';
                document.getElementById('editCategory').value = video.category || '';
                document.getElementById('editDescription').value = video.description || '';
                document.getElementById('editDuration').value = video.duration || '';
                document.getElementById('editTags').value = video.tags || '';
                document.getElementById('editEvent').value = video.event || '';

                // Update subcategories and set value
                updateEditSubcategories();
                setTimeout(() => {
                    document.getElementById('editSubcategory').value = video.subcategory || '';
                }, 50);

                // Show modal
                document.getElementById('editModal').classList.remove('hidden');
                document.getElementById('editModal').classList.add('flex');
            } catch (error) {
                alert('Error loading video: ' + error.message);
            }
        }

        function closeEditModal() {
            document.getElementById('editModal').classList.add('hidden');
            document.getElementById('editModal').classList.remove('flex');
        }

        // Edit form submission
        document.getElementById('editVideoForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            const videoId = document.getElementById('editVideoId').value;
            const data = {
                title: document.getElementById('editTitle').value,
                category: document.getElementById('editCategory').value,
                subcategory: document.getElementById('editSubcategory').value,
                description: document.getElementById('editDescription').value,
                duration: document.getElementById('editDuration').value,
                tags: document.getElementById('editTags').value,
                event: document.getElementById('editEvent').value
            };

            try {
                const response = await fetch(`/admin/edit-video/${videoId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });

                const result = await response.json();

                if (result.error) {
                    alert(result.error);
                } else {
                    closeEditModal();
                    location.reload();
                }
            } catch (error) {
                alert('Error updating video: ' + error.message);
            }
        });

        // ============================================
        // Background Conversion Tracking
        // ============================================
        let conversionPollingInterval = null;

        function startConversionPolling() {
            if (conversionPollingInterval) return; // Already polling
            conversionPollingInterval = setInterval(pollConversionStatus, 2000);
            pollConversionStatus(); // Immediate first poll
        }

        function stopConversionPolling() {
            if (conversionPollingInterval) {
                clearInterval(conversionPollingInterval);
                conversionPollingInterval = null;
            }
        }

        async function pollConversionStatus() {
            try {
                const response = await fetch('/conversion/all');
                const jobs = await response.json();

                const panel = document.getElementById('conversionStatusPanel');
                const list = document.getElementById('conversionJobsList');
                const inlinePanel = document.getElementById('inlineConversionStatus');
                const inlineList = document.getElementById('inlineConversionList');
                const inlineCount = document.getElementById('inlineConversionCount');

                const jobIds = Object.keys(jobs);
                if (jobIds.length === 0) {
                    panel.classList.add('hidden');
                    inlinePanel.classList.add('hidden');
                    stopConversionPolling();
                    return;
                }

                panel.classList.remove('hidden');
                inlinePanel.classList.remove('hidden');

                // Check if all jobs are done
                const activeJobs = jobIds.filter(id => !['completed', 'failed'].includes(jobs[id].status));
                if (activeJobs.length === 0) {
                    stopConversionPolling();
                }

                // Render jobs
                list.innerHTML = jobIds.map(jobId => {
                    const job = jobs[jobId];
                    let statusClass = 'text-gray-400';
                    let statusIcon = '‚è≥';
                    let progressBar = '';

                    if (job.status === 'completed') {
                        statusClass = 'text-green-400';
                        statusIcon = '‚úì';
                    } else if (job.status === 'failed') {
                        statusClass = 'text-red-400';
                        statusIcon = '‚úó';
                    } else if (job.status === 'converting') {
                        statusClass = 'text-yellow-400';
                        statusIcon = '‚öôÔ∏è';
                        progressBar = `<div class="w-full bg-gray-600 rounded-full h-2 mt-2">
                            <div class="bg-yellow-500 h-2 rounded-full transition-all" style="width: ${job.progress || 0}%"></div>
                        </div>`;
                    } else if (job.status === 'generating_thumbnail') {
                        statusClass = 'text-blue-400';
                        statusIcon = 'üñºÔ∏è';
                        progressBar = `<div class="w-full bg-gray-600 rounded-full h-2 mt-2">
                            <div class="bg-blue-500 h-2 rounded-full transition-all" style="width: ${job.progress || 0}%"></div>
                        </div>`;
                    }

                    const statusLabels = {
                        'queued': 'Queued',
                        'converting': 'Converting...',
                        'generating_thumbnail': 'Generating thumbnail...',
                        'completed': 'Completed',
                        'failed': 'Failed'
                    };

                    return `
                        <div class="bg-gray-700 rounded-lg p-3">
                            <div class="flex justify-between items-start">
                                <div class="flex-1 min-w-0">
                                    <p class="font-medium text-white truncate">${job.title || job.filename}</p>
                                    <p class="text-sm ${statusClass}">
                                        ${statusIcon} ${statusLabels[job.status] || job.status}
                                        ${job.error ? ` - ${job.error}` : ''}
                                    </p>
                                    ${progressBar}
                                </div>
                                ${job.status === 'completed' ? `
                                    <a href="/video/${job.video_id}" target="_blank" class="text-blue-400 hover:text-blue-300 text-sm ml-3">View</a>
                                ` : ''}
                            </div>
                        </div>
                    `;
                }).join('');

                // Also update inline conversion status
                const completedCount = jobIds.filter(id => jobs[id].status === 'completed').length;
                const activeCount = jobIds.filter(id => !['completed', 'failed'].includes(jobs[id].status)).length;
                inlineCount.textContent = `${completedCount}/${jobIds.length} complete`;

                inlineList.innerHTML = jobIds.map(jobId => {
                    const job = jobs[jobId];
                    let statusColor = 'bg-gray-500';
                    let statusText = job.status;
                    let progressWidth = job.progress || 0;

                    if (job.status === 'completed') {
                        statusColor = 'bg-green-500';
                        statusText = 'Done';
                        progressWidth = 100;
                    } else if (job.status === 'failed') {
                        statusColor = 'bg-red-500';
                        statusText = 'Failed';
                    } else if (job.status === 'converting') {
                        statusColor = 'bg-yellow-500';
                        statusText = `Converting ${progressWidth}%`;
                    } else if (job.status === 'generating_thumbnail') {
                        statusColor = 'bg-blue-500';
                        statusText = 'Thumbnail...';
                        progressWidth = 85;
                    } else if (job.status === 'uploading') {
                        statusColor = 'bg-purple-500';
                        statusText = 'Uploading to cloud...';
                        progressWidth = 95;
                    } else if (job.status === 'queued') {
                        statusColor = 'bg-gray-500';
                        statusText = 'Queued';
                        progressWidth = 0;
                    }

                    return `
                        <div class="bg-gray-800 rounded p-2">
                            <div class="flex justify-between items-center mb-1">
                                <span class="text-white text-sm truncate flex-1 mr-2">${job.title || job.filename}</span>
                                <span class="text-xs ${job.status === 'completed' ? 'text-green-400' : job.status === 'failed' ? 'text-red-400' : 'text-yellow-400'}">${statusText}</span>
                            </div>
                            <div class="w-full bg-gray-600 rounded-full h-1.5">
                                <div class="${statusColor} h-1.5 rounded-full transition-all duration-300" style="width: ${progressWidth}%"></div>
                            </div>
                        </div>
                    `;
                }).join('');

            } catch (error) {
                console.error('Error polling conversion status:', error);
            }
        }

        async function clearCompletedConversions() {
            try {
                await fetch('/conversion/clear-completed', { method: 'POST' });
                pollConversionStatus();
            } catch (error) {
                console.error('Error clearing completed conversions:', error);
            }
        }

        // Check for active conversions on page load
        document.addEventListener('DOMContentLoaded', function() {
            pollConversionStatus();
        });

        // Local Converter Modal
        function showConverterModal() {
            document.getElementById('converterModal').classList.remove('hidden');
        }

        function hideConverterModal() {
            document.getElementById('converterModal').classList.add('hidden');
        }

        function copyConverterCommand() {
            const cmd = document.getElementById('converterCommand').textContent;
            navigator.clipboard.writeText(cmd).then(() => {
                const btn = document.getElementById('copyBtn');
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = 'Copy Command', 2000);
            });
        }

        // Server-side conversion via drag & drop
        let converterFiles = [];

        function handleConverterDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            document.getElementById('converterDropZone').classList.remove('border-orange-500', 'bg-orange-900/20');

            const items = e.dataTransfer.items;
            converterFiles = [];

            const validExts = ['mkv', 'avi', 'mts', 'm2ts'];

            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                if (item.kind === 'file') {
                    const entry = item.webkitGetAsEntry ? item.webkitGetAsEntry() : null;
                    if (entry && entry.isDirectory) {
                        traverseDirectory(entry, '');
                    } else {
                        const file = item.getAsFile();
                        const ext = file.name.split('.').pop().toLowerCase();
                        if (validExts.includes(ext)) {
                            converterFiles.push(file);
                        }
                    }
                }
            }

            setTimeout(updateConverterFileList, 500);
        }

        function traverseDirectory(entry, path) {
            const validExts = ['mkv', 'avi', 'mts', 'm2ts'];
            const reader = entry.createReader();
            reader.readEntries(function(entries) {
                entries.forEach(function(ent) {
                    if (ent.isFile) {
                        ent.file(function(file) {
                            const ext = file.name.split('.').pop().toLowerCase();
                            if (validExts.includes(ext)) {
                                converterFiles.push(file);
                                updateConverterFileList();
                            }
                        });
                    } else if (ent.isDirectory) {
                        traverseDirectory(ent, path + ent.name + '/');
                    }
                });
            });
        }

        function updateConverterFileList() {
            const listDiv = document.getElementById('converterFileList');
            const startBtn = document.getElementById('startConversionBtn');

            if (converterFiles.length === 0) {
                listDiv.innerHTML = '<p class="text-gray-500 text-sm">No MKV/AVI/MTS files found</p>';
                startBtn.classList.add('hidden');
                return;
            }

            const totalSize = converterFiles.reduce((sum, f) => sum + f.size, 0);
            const totalMB = (totalSize / 1024 / 1024).toFixed(1);

            listDiv.innerHTML = `
                <p class="text-green-400 text-sm mb-2">${converterFiles.length} file(s) ready (${totalMB} MB total)</p>
                <div class="max-h-24 overflow-y-auto text-xs text-gray-400">
                    ${converterFiles.map(f => `<div>${f.name}</div>`).join('')}
                </div>
            `;
            startBtn.classList.remove('hidden');
        }

        async function startServerConversion() {
            if (converterFiles.length === 0) return;

            const progressDiv = document.getElementById('converterProgress');
            const dropZone = document.getElementById('converterDropZone');
            const startBtn = document.getElementById('startConversionBtn');

            dropZone.classList.add('hidden');
            startBtn.classList.add('hidden');
            progressDiv.classList.remove('hidden');

            const CHUNK_SIZE = 5 * 1024 * 1024; // 5MB

            for (let i = 0; i < converterFiles.length; i++) {
                const file = converterFiles[i];
                const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
                const uploadId = Date.now().toString(36) + Math.random().toString(36).substr(2);
                const mbTotal = (file.size / 1024 / 1024).toFixed(1);

                progressDiv.innerHTML = `
                    <div class="text-sm mb-2">File ${i + 1}/${converterFiles.length}: ${file.name}</div>
                    <div class="bg-gray-700 rounded-full h-2 overflow-hidden mb-2">
                        <div id="convProgress" class="bg-orange-500 h-full transition-all" style="width: 0%"></div>
                    </div>
                    <div id="convStatus" class="text-xs text-gray-400">Uploading... 0%</div>
                `;

                // Upload chunks
                for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
                    const start = chunkIndex * CHUNK_SIZE;
                    const end = Math.min(start + CHUNK_SIZE, file.size);
                    const chunk = file.slice(start, end);

                    const percent = Math.round(((chunkIndex + 1) / totalChunks) * 80);
                    document.getElementById('convProgress').style.width = percent + '%';
                    document.getElementById('convStatus').textContent = `Uploading... ${percent}% (${(end/1024/1024).toFixed(1)}/${mbTotal} MB)`;

                    const formData = new FormData();
                    formData.append('chunk', chunk);
                    formData.append('upload_id', uploadId);
                    formData.append('chunk_index', chunkIndex);
                    formData.append('total_chunks', totalChunks);
                    formData.append('filename', file.name);

                    try {
                        await fetch('/admin/upload-chunk', { method: 'POST', body: formData });
                    } catch (err) {
                        progressDiv.innerHTML = `<div class="text-red-400">Failed to upload ${file.name}: ${err.message}</div>`;
                        continue;
                    }
                }

                // Complete upload and start conversion
                document.getElementById('convProgress').style.width = '85%';
                document.getElementById('convStatus').textContent = 'Assembling and starting conversion...';

                try {
                    const response = await fetch('/admin/upload-chunk-complete', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            upload_id: uploadId,
                            filename: file.name,
                            title: file.name.replace(/\.[^/.]+$/, '').replace(/[_-]/g, ' '),
                            category: '',
                            subcategory: '',
                            event: ''
                        })
                    });
                    const result = await response.json();

                    if (result.success) {
                        document.getElementById('convProgress').style.width = '100%';
                        document.getElementById('convStatus').textContent = 'Converting in background...';
                    }
                } catch (err) {
                    progressDiv.innerHTML += `<div class="text-red-400 text-sm">Error: ${err.message}</div>`;
                }
            }

            progressDiv.innerHTML = `
                <div class="text-green-400 mb-2">${converterFiles.length} file(s) uploaded and converting!</div>
                <div class="text-gray-400 text-sm">Check the conversion progress panel on this page.</div>
                <button onclick="resetConverter()" class="mt-3 px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded text-sm">Upload More</button>
            `;

            converterFiles = [];
            startConversionPolling();
        }

        function resetConverter() {
            document.getElementById('converterDropZone').classList.remove('hidden');
            document.getElementById('converterProgress').classList.add('hidden');
            document.getElementById('converterFileList').innerHTML = '';
            document.getElementById('startConversionBtn').classList.add('hidden');
            converterFiles = [];
        }

        // Local conversion path input
        function updateLocalCommand() {
            const path = document.getElementById('localPathInput').value.trim();
            const cmd = `cd ~/Desktop/projects/video-library && ./convert-videos.sh "${path || '/path/to/videos'}"`;
            document.getElementById('localFullCommand').textContent = cmd;
        }

        function copyLocalFullCommand() {
            const path = document.getElementById('localPathInput').value.trim();
            if (!path) {
                alert('Please paste a folder path first!');
                return;
            }
            const cmd = `cd ~/Desktop/projects/video-library && ./convert-videos.sh "${path}"`;
            navigator.clipboard.writeText(cmd).then(() => {
                const btn = event.target;
                btn.textContent = 'Copied!';
                btn.classList.remove('bg-green-600', 'hover:bg-green-700');
                btn.classList.add('bg-gray-600');
                setTimeout(() => {
                    btn.textContent = 'Copy Command';
                    btn.classList.add('bg-green-600', 'hover:bg-green-700');
                    btn.classList.remove('bg-gray-600');
                }, 2000);
            });
        }
    </script>

    <!-- Local Converter Modal -->
    <div id="converterModal" class="hidden fixed inset-0 bg-black/70 flex items-center justify-center z-50" onclick="if(event.target === this) hideConverterModal()">
        <div class="bg-gray-800 rounded-lg p-6 max-w-2xl w-full mx-4 shadow-2xl max-h-[90vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold flex items-center gap-2">
                    <svg class="w-6 h-6 text-orange-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                    </svg>
                    Video Converter
                </h3>
                <button onclick="hideConverterModal()" class="text-gray-400 hover:text-white text-2xl">&times;</button>
            </div>

            <!-- Server Conversion Drop Zone -->
            <div class="mb-6">
                <p class="text-gray-300 mb-3">Drop MKV, AVI, or MTS files here to convert and add to library:</p>

                <div id="converterDropZone"
                    class="border-2 border-dashed border-gray-600 rounded-lg p-8 text-center hover:border-orange-500 hover:bg-orange-900/10 transition cursor-pointer"
                    ondrop="handleConverterDrop(event)"
                    ondragover="event.preventDefault(); this.classList.add('border-orange-500', 'bg-orange-900/20')"
                    ondragleave="this.classList.remove('border-orange-500', 'bg-orange-900/20')"
                    onclick="document.getElementById('converterFileInput').click()">
                    <svg class="w-12 h-12 mx-auto text-orange-400 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                    </svg>
                    <p class="text-gray-300">Drop files or folders here</p>
                    <p class="text-gray-500 text-sm mt-1">MKV, AVI, MTS files will be converted to MP4</p>
                </div>
                <input type="file" id="converterFileInput" class="hidden" multiple accept=".mkv,.avi,.mts,.m2ts" onchange="converterFiles = Array.from(this.files); updateConverterFileList()">

                <div id="converterFileList" class="mt-3"></div>

                <button id="startConversionBtn" onclick="startServerConversion()" class="hidden mt-3 w-full px-4 py-3 bg-orange-600 hover:bg-orange-700 rounded font-bold">
                    Start Conversion
                </button>

                <div id="converterProgress" class="hidden mt-4 p-4 bg-gray-900 rounded"></div>
            </div>

            <div class="border-t border-gray-700 pt-4">
                <p class="text-gray-400 text-sm mb-3"><strong>Or convert locally (faster for large files):</strong></p>

                <div class="mb-3">
                    <label class="block text-gray-400 text-xs mb-1">Paste folder path (right-click folder in Finder ‚Üí "Copy as Pathname"):</label>
                    <input type="text" id="localPathInput"
                        class="w-full px-3 py-2 bg-gray-900 border border-gray-600 rounded text-green-400 text-sm focus:border-green-500 focus:outline-none"
                        placeholder="/Users/you/path/to/videos"
                        oninput="updateLocalCommand()">
                </div>

                <div id="localCommandBox" class="bg-gray-900 rounded p-3 mb-3">
                    <p class="text-gray-500 text-xs mb-1">Terminal command:</p>
                    <code id="localFullCommand" class="text-green-400 text-xs break-all">cd ~/Desktop/projects/video-library && ./convert-videos.sh "/path/to/videos"</code>
                </div>

                <div class="flex gap-2">
                    <button onclick="copyLocalFullCommand()" class="px-3 py-1 bg-green-600 hover:bg-green-700 rounded text-sm">
                        Copy Command
                    </button>
                    <a href="/static/convert-videos.sh" download class="px-3 py-1 bg-gray-600 hover:bg-gray-700 rounded text-sm">
                        Download Script
                    </a>
                </div>

                <div class="mt-3 p-2 bg-blue-900/30 border border-blue-700 rounded text-xs text-gray-300">
                    <strong class="text-blue-400">How to get path:</strong> In Finder, right-click your folder ‚Üí Hold <kbd class="bg-gray-700 px-1 rounded">Option</kbd> ‚Üí Click "Copy as Pathname"
                </div>
            </div>
        </div>
    </div>
</body>
</html>
